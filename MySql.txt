1.二叉查找树（BST）:
（1）如果它的左子树不为空，左子树上的结点的值均小于它的根结点的值
（2）如果它的右子树不为空，右子树上的结点的值均大于它的根节点的值
查找时间复杂度：平均时间复杂度为0(logN),最坏的情况为O(n)
问题：查找算法的性能取决于二叉树的结构，如果数据呈有序排序，则二叉树序树为线性的，查找时间复杂度为O（n）


平衡二叉树（AVL）：
（1）特征如上
（2）左子树和右子树的深度之差的绝对值不超过1
问题：追求绝对的高度平衡，随着树的高度的增加，动态插入和删除的代价也随之增加

红黑树：
（1）特征如二叉查找树
（2）根节点是黑色的
（3）每个节点要么是黑色的，要么就是红色的
（4）每个叶子节点为黑色的（叶子节点指的是为空的叶子节点）
（5）如果一个节点是红色的，则它的子节点必须的黑色的
（6）从一个节点到该节点的子孙节点的所有路径上包含相同的黑色节点数量
问题：
（1）查找代价：由于红黑树的性质（最长路径的长度不超过最短路径的两倍），查找代价基本在O(logN),可能比AVL稍微逊色一点，不过平衡性比AVL好
（2）增加和删除代价：任何平衡都可以在3次旋转之内解决


B-树也就是B树（平衡的多路查找树），具有以下特点：（假设M阶树）

1.根结点至少有两个子女。
2.每个中间结点都包含K-1个元素和K个孩子。元素个数应该小于等于M-1，孩子个数小于等于M
3.所有的叶子结点都位于同一层。
4.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

出现的原因：二叉树的查找速度较快，取决于树的高度，但由于数据库索引存放在磁盘上，当数据量比较大的时候，
当我们利用索引查询的时候，不能把索引全部加载到内存中，能做的就是逐一加载每一个磁盘页，这里的磁盘页对应着索引树的节点，
所以应当减少磁盘IO次数。所以B-树（平衡的多路查找树）正可以解决这个问题，虽然在节点上元素较多，比较的次数较多，
但由于节点上的元素是加载到内存中进行比较的，速度比较快。


B+树与B-树的区别：
（1）有K个子树的中间节点包含有K个元素（B-树中是K-1个元素）
（2）B+树的每个元素只包含索引，不包含数据，全部数据存放在叶子节点上（B-树不是）
（3）B+树的非终端节点只是看成索引部分，节点中仅含有其子树中的最大值或者最小值关键字
（4）叶子节点奔上依照关键字的大小自小而大顺序连接


B+树相对B-树的优势：
1.磁盘IO次数更少
2.查询性能更加稳定
3.范围查询更加简便。






2.MySql数据库优化：

索引优化：
（1）独立的列，不要对索引进行计算
（2）当有几个字段频繁查询的时候，可以使用联合索引
（3）索引列的顺序，一般讲选择性较强的索引放在最左边
（4）对于那些在查询中很少使用或者参考的列不应该创建索引
（5）对于那些只有很少数据值的列也不应该增加索引
（6）对于那些定义为text, image和bit数据类型的列不应该增加索引


数据表结构优化：
（1）将字段较多的表分解成多个表，可以将一些使用频率较低的字段单独分离出来，存储为一张表，加快查询速度
（2）增加中间表，对于经常需要进行联合查询的表，可以增加中间表以提高查询效率
（3）增加冗余字段。学生表和学院表，可以在学生表中增加一个冗余字段，学院名字，加快查询速度


查询优化：
1、有索引但未被用到的情况（不建议）
(1) Like的参数以通配符开头时
(2) where条件不符合最左前缀原则时
（3）尽量避免使用！= 或 <>操作符，
(4) 索引列参与计算
(5) 对字段进行null值判断
(6) 使用or来连接条件
2、避免select *
3、order by 语句优化
4、GROUP BY语句优化
5、用 exists 代替 in
6、使用 varchar/nvarchar 代替 char/nchar
7、能用DISTINCT的就不用GROUP BY
8、能用UNION ALL就不要用UNION
9、在Join表的时候使用相当类型的例，并将其索引





Innodb与Myisam引擎的区别与应用场景
1. 区别：

（1）事务处理：

MyISAM是非事务安全型的，而InnoDB是事务安全型的（支持事务处理等高级处理）；

（2）锁机制不同：

MyISAM是表级锁，而InnoDB是行级锁；

（3）select ,update ,insert ,delete 操作：

MyISAM：如果执行大量的SELECT，MyISAM是更好的选择
--原因：
如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，
而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。
这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表
（4）查询表的行数不同：

MyISAM：select count(*) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(*)语句包含   where条件时，两种表的操作是一样的
InnoDB ： InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行
（5）外键支持：
mysiam表不支持外键，而InnoDB支持
2. 为什么MyISAM会比Innodb 的查询速度快。

INNODB在做SELECT的时候，要维护的东西比MYISAM引擎多很多；
1）数据块，INNODB要缓存，MYISAM只缓存索引块，  这中间还有换进换出的减少； 
2）innodb寻址要映射到块，再到行，MYISAM 记录的直接是文件的OFFSET，定位比INNODB要快
3）INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护
MVCC ( Multi-Version Concurrency Control )多版本并发控制 
3. 应用场景
MyISAM适合：(1)做很多count 的计算；(2)插入不频繁，查询非常频繁；(3)没有事务。

InnoDB适合：(1)可靠性要求比较高，或者要求事务；(2)表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。






6.数据库日志
错误日志：记录MySql启动、运行或停止时出现的问题
慢查询日志：记录查询时长超过指定时间的查询语句
查询日志：记录用户的所有操作，包括增删查改
二进制日志：记录修改数据或者引起mysql数据变化的sql语句


