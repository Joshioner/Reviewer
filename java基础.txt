1.装箱：将基本数据类型包装成包装类型
  拆箱：将包装类型拆为基本数据类型
实现：装箱的时候会调用Integee.Valueof(num)方法，拆箱的时候会调用Integer.initValue(num)方法（Double和Float除外，因为Double和Float的数值个数是无法统计的）

注意：当 "=="运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，
而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。

好处：节省了常用数值的内存开销和创建对象的开销，提高了效率。

2.抽象类和接口的区别：
如果以下任何一种语句适用于您的情况，请考虑使用抽象类：

 1.你想在几个密切相关的类中共享代码。
 
 2.您期望扩展抽象类的类具有许多通用的方法或字段，或者需要访问修饰符而不是公共的（例如protected和private）。
 
 3.您想要声明非静态或非最终字段。这使您可以定义可访问和修改其所属对象状态的方法。
 
如果以下任何一种语句适用于您的情况，请考虑使用接口：
      
	1.你期望不相关的类将实现你的接口。例如，Comparable和Cloneable接口由许多不相关的类实现。 

    2.您想要指定特定数据类型的行为，但不关心谁实现其行为。

    3.你想利用多重继承。
	
	
3.HashMap中需要保证容量capacity 必须保证为 2 的 n 次方。
原因：第一个步骤是确定桶下标
（1）计算hash值
（2）hash%capacity,取得桶下标，如果容量为2的n次方，则可以转换为  位运算  hash&(capacity - 1),计算速度较快。

4.Java内存模型与线程
 
 内存模型：为了屏蔽掉操作系统和各种硬件的内存访问差异（记住那个图形，8个原子性操作。lock,unlock,read,load,use,assign,store,write）
  
  volatile的特点：1. 可见性（一个线程修改了这个变量的值，其他线程可立即得知）
                  2. 禁止指令重排（单例模式）			  
				  //双重加锁检验
				  private Person person;
				  public static getInstance(){
				    if(person == null){
					 synchronized(Person.class){
					    if(person == null){
						   person = new Person();  ----->发生的指令 1.分配内存空间  2.初始化对象 3.将初始化的对象指向分配好的空间
						                      -------->可能发生的情况：1 3 2，还没初始化对象就先分配空间，报错（volatile可以禁止指令重排）
						}
					 }
					}
				  }
	
  内存模型的特点：
      1.原子性（synchronized 	注意：volatite不能保证原子性，也不能保证线程安全）  
	  2.可见性（synchronized，volatite可以保证可见性）
	  3.有序性（synchronized，volatite可以保证有序性）
---------有一个 ”先行发生规则“也保证了线程的有序性（8条）

  
  线程：
实现方式：
1.使用内核线程实现
2.使用用户线程实现
3.使用内核线程加用户线程实现
  
  线程的状态切换：新建、运行、等待（主动）、阻塞（被动）、结束
  
  
  

5.MySql数据库优化：

索引优化：
（1）独立的列，不要对索引进行计算
（2）当有几个字段频繁查询的时候，可以使用联合索引
（3）索引列的顺序，一般讲选择性较强的索引放在最左边
（4）对于那些在查询中很少使用或者参考的列不应该创建索引
（5）对于那些只有很少数据值的列也不应该增加索引
（6）对于那些定义为text, image和bit数据类型的列不应该增加索引


数据表结构优化：
（1）将字段较多的表分解成多个表，可以将一些使用频率较低的字段单独分离出来，存储为一张表，加快查询速度
（2）增加中间表，对于经常需要进行联合查询的表，可以增加中间表以提高查询效率
（3）增加冗余字段。学生表和学院表，可以在学生表中增加一个冗余字段，学院名字，加快查询速度


查询优化：
1、有索引但未被用到的情况（不建议）
(1) Like的参数以通配符开头时
(2) where条件不符合最左前缀原则时
（3）尽量避免使用！= 或 <>操作符，
(4) 索引列参与计算
(5) 对字段进行null值判断
(6) 使用or来连接条件
2、避免select *
3、order by 语句优化
4、GROUP BY语句优化
5、用 exists 代替 in
6、使用 varchar/nvarchar 代替 char/nchar
7、能用DISTINCT的就不用GROUP BY
8、能用UNION ALL就不要用UNION
9、在Join表的时候使用相当类型的例，并将其索引



6.数据库日志
错误日志：记录MySql启动、运行或停止时出现的问题
慢查询日志：记录查询时长超过指定时间的查询语句
查询日志：记录用户的所有操作，包括增删查改
二进制日志：记录修改数据或者引起mysql数据变化的sql语句


7.转发和重定向的区别：
转发是在服务器端的行为，重定向是客户端的行为；
转发的话的地址栏URL不变，重定向的话地址URL发送了变化；
转发的是同一次请求，重定向会执行两次请求；
转发只能转发到本应用内的url,重定向可以请求本应用外的资源；
转发之后保存在request中的信息还是共享的，而重定向则不是。


8.SpringMVC和Struts的区别：
（1）SpringMVC是方法级别的拦截，一个方法对应一个request上下文，是单例的；
     Struts是基于类的设计，是多例的，每次发一个请求，都会实例一个action
 （2）SpringMVC的入口是servlet，而Struts的入口是filter,导致了这两个的机制不同
        servlet:主要进行逻辑处理，读取客户端的请求信息，处理完请求对象之后，将返回的信息封装在响应对象中，返回给客户端
		Fielter:在一个请求到达servlet之前，先对请求信息进行预处理，当servlet处理完之后，可以处理http响应信息
		可以做进行字符编码的过滤，实现用户自动登录，禁止页面缓存。
 （3）struts有以自己的interceptor机制，springmvc用的是独立的AOP方式。这样导致struts的配置文件量还是比springmvc大
 （4）SpringMVC可以很容易的处理ajax请求，只需加一个注解@ResponseBody,则可以直接返回json数据，处理很方便
 
 
 
 9.http请求方法：
 get:请求指定的页面信息
 post:提交数据进行处理请求
 delete:请求服务器删除特定的页面/资源；
 head:类似于get方法，用于获取报头
 trace:回显服务器端收到的请求，主要用于诊断和测试
 connect：http1.1协议中保留的可将连接改为管道的代理服务器
 options:允许客户端查看服务器端的性能

 
 10.session和cookie的区别：
 （1）cookie数据存放在客户的浏览器上，session数据放在服务器上。

（2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。

（3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。

（4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

（5）可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。

11.粘包、拆包
  
  发生原因 
   1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。

   2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。

   3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。

   4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

   
   
   

   
   
   
   
 12.Spring IOC的理解：
 IOC:控制反转，将创建对象的主动权交给容器去创建。
 DI:依赖注入，容器创建完对象之后，当我们需要对象的时候帮我们注入到其中。
 
 ====好处：（1）降低了模块间的耦合度，当需要对象的时候直接注入即可。（2）方便进行单元测试。
 
 ====技术剖析
 利用了反射机制。
 好处：在运行的过程中，动态的获取类的对象、方法、属性等
 缺点：（1）反射需要消耗性能，在一定程度上会降低效率 （2）会破坏对象的安全性，可以动态获取私有的一些属性，破坏了它的权限性。
 
 
 
 
 13.http状态码：
 100：服务端已经接受到了客户端的请求，客户端应当继续发送剩余的请求
 101：服务器遵循客户端的请求，转换到另外一种协议
 
 200：请求成功
 201：请求成功并且服务器创建了新的资源
 202：服务器已经接受请求，但尚未处理
 203：请求成功，非授权信息。但返回的meta信息不在原始的服务器，而是一个副本。
 204：请求成功，但未返回内容。
 205：请求成功，要求请求者重置文档视图。
 206：服务器已经成功处理了部分请求。
 
 
 300：客户端请求的资源可以在多个位置被找到，这些位置在返回的文档中已经列出。
 301：请求的资源被永久的转移到了新的URL
 302：请求的资源临时被转移到了新的URL，客户应当继续使用原有URL
 303：请求的资源可以在另一个URL找到，并且客户端必须通过GET方式访问那个资源
 304：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
 305：所请求的资源必须通过代理访问。
 306：已经废弃的HTTP状态码
 307：临时重定向。通过get访问资源
 
 400：客户端的语法错误
 401：请求要求用户认证。
 402：保留着，将来使用
 403：服务器理解客户端的请求，但拒绝此请求，被拒绝了
 404：找不到对应的资源。
 405：客户端请求的方法被禁止。
 
 500：服务器端内部错误，无法完成请求
 501：服务器不支持当前请求的功能。
 502：网关或者代理服务器尝试执行请求，从上游服务器收到无效的响应。
 503：由于超载或者系统维护，服务器暂时无法处理客户端的请求
 504；充当网关或者代理的服务器，未及时收到服务器端的响应。
 505：服务器不支持请求的HTTP版本协议。
 
 
14.mybatis中"#"和"$"的区别
#{} 和 ${} 在预编译中的处理是不一样的。#{} 在预处理时，会把参数部分用一个占位符 ? 代替，而 ${} 则只是简单的字符串替换


15.Synchrpnized的实现原理：
synchronized锁在同步代码块中的实现原理：通过monitorenter和Monitorexit指令来实现，进入代码块的时候获取monitorenter指令，退出使用monitorexit

synchronized锁在方法上的实现原理：使用ACC_SYNCHRONIZED，指明该方法是一个同步方法，从而执行响应的同步调用。



15.线程和进程的区别：
（1）资源：进程是资源分配的基本单位，线程的CPU调度的基本单位。
一个进程内的线程是共享该进程内的资源的。 
一个线程只能属于一个进程，一个进程可以包含多个线程，一个进程至少有一个线程。
（2）系统开销：同一进程内线程的切换不会引起进程的切换，从一进程的内线程切换到另一进程的线程，会引起进程切换。
进程的创建和销毁开销比较大，需要系统进行分配和回收资源；进程间的切换开销也比较大，涉及当前执行进程cpu环境的保存以及新调度进程CPU的设置，而
线程切换只需保存和设置少量寄存器内容，开销很小。

几种进程间的通信方式

（1）管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。

（2）有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。

（3）信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

（4）消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

（5）信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。

（6）共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。

（7）套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。


几种线程间的通信机制

1、锁机制

     1.1 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。

     1.2 读写锁：允许多个线程同时读共享数据，而对写操作互斥。

     1.3 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

2、信号量机制：包括无名线程信号量与有名线程信号量

3、信号机制：类似于进程间的信号处理。

线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。


-------------------------------------------------------------------------------------------------------------

16.Spring学习之AppliactionContext与BeanFactory的区别  
（1）BeanFactory采用的是延迟加载，只有当使用时才对bean进行加载实例化；AppliactionContext则是容器启动时就一次性创建所有的bean。
这样，在容器启动时就可以发现spring配置中的错误
（2）AppliactionContext与BeanFactory都支持BeanPostProcessor的使用，但BeanFactory需要手动注册，而AppliactionContext是自动注册
（3）AppliactionContext是BeanFactory的一个子类，对beanFactory进行扩展，拥有更多的功能
    ---实现了MessgaeResource接口，支持国际化处理
	---ApplicationContext扩展了ResourceLoader接口，从而可以用来加载多个资源文件，而beanFactory是没有扩展ResourceLoader接口的
	

   
				  
 
17.CountdownLatch 和 join的区别
CountDownLatch与join的区别：调用thread.join() 方法必须等thread 执行完毕，当前线程才能继续往下执行，
而CountDownLatch通过计数器提供了更灵活的控制，只要检测到计数器为0当前线程就可以往下执行而不用管相应的thread是否执行完毕。





